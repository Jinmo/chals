# steps (Reversing)

문제 지문은 DESCRIPTION.txt에 있습니다.

Vectored Exception Handling (VEH)를 이용해서 특정 함수의 난독화를 한
명령어씩만 풀고 다시 재난독화하는 방식으로 프로그램을 실행하는 컨셉의
리버싱 문제입니다.

main 함수가 실행되기 전에는 C++ 전역 변수에 대한 생성자가 실행되는데, 여기서 VEH 등록 후 main의 첫 명령어를 중단점 (int3)으로 바꿔주었습니다. 이후 single step flag를 이용하여 위의 루틴을 구현했습니다.

## 풀이

프로그램을 켜봅시다. 비밀번호를 입력받고 틀리면 Wrong!을 출력하는군요.

먼저 main 함수가 난독화되어있고, main 실행 전에 실행되는 루틴들이 있다는 것을 인지해야 합니다. 엔트리포인트부터 디버깅해보면 알 수 있습니다.

> TMI: 이들을 보통 MSVC에서는 initterm 함수가 실행해줍니다.
> 보통 IDA가 F12 (Lumina)를 누르면 바꿔주니까 자주 보게 되더군요.

해당 루틴에서는 VEH 핸들러 등록 및 main의 첫 명령어를 중단점으로 바꿔줍니다.
이 VEH 핸들러와 main에 삽입되는 중단점과의 관계를 생각해봅시다.
(1) int3은 예외를 발생시킬 것이고, (디버거에서 확인할 수 있습니다)
(2) VEH가 등록되어있으니 VEH가 이 때 실행될 것입니다.

따라서, main 대신 VEH에 중단점을 걸고 디버깅을 시작합니다.

### 난독화 풀기

VEH를 분석해보면, 익셉션이 난 실행 위치의 메모리를 조작하는 것이 보입니다.
해당 핸들러는 그 후 해당 위치에서 프로그램을 재개하도록 됩니다. (`EXCEPTION_CONTINUE_EXECUTION == -1` 리턴)
프로그램은 문제 없이 실행되기 때문에, 조작되는 메모리가 실행 가능한 형태의
명령어라는 점을 알 수 있습니다. 또는 VEH를 다시 부르겠지요, 왜냐하면 디버거를
붙이기 전에는 프로그램은 제대로 실행이 되고있었기 때문입니다.

해당 위치를 다시 디스어셈블해보면 다른 함수와 비슷한 시작부를 가지고 있음을 알 수 있습니다.
이런 확인 과정을 한 명령어, 한 명령어씩 반복하다보면 VEH가 난독화 해제를 한 명령어씩
반복적으로 하고, 다시 되돌려놓는다는 점을 알게 되겠지요.

main 함수가 아주 크진 않아서 난독화를 푸는 데 자동화를 하지 않아도 되지만, 자동화를 해보는 것도 물론 나쁘진 않을 것입니다.
난독화 해제는 16바이트 단위로 이루어지는데, 앞에서부터 난독화를 16바이트 해제 후 명령어 하나를 디코딩,
그리고 그 다음 주소를 얻어서 다시 해제를 반복해주면 정적으로도 난독화를 풀 수 있습니다.

난독화가 해제된 뒤에는 [Feistel 구조의 암호](https://en.wikipedia.org/wiki/Feistel_cipher)를 보게 될 것입니다. 푸는 방법은 위키피디아에 나온 대로, 각 라운드에 들어가는 키를 반대로 넣어주면 됩니다.

[난독화 코드](obfuscator.py) 및 암호문을 검증 및 생성하는 데 [쓰인 코드](feistel.py)를 첨부합니다.
또한 [프로그램의 원본 코드](steps/)를 첨부하였습니다.

### 플래그

```
KOREA{step_by_step_obfuscation_fun}
```
